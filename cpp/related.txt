

class A {
public:
   A():{}
   A(string* res):d(res){}
   // copy c'tor
   A(A& obj) :d(new string(*obj.d)){}
   // move c'tor
   A(A&& o): d(o.d){o.d = nullptr;}
   // copy assignment
   A& operator=(A& o){if(&o != this){d = new string(*o.d);} return *this;}

   // move assignment
   A& operator=(A&& o){
     if(&o != this){
        if(d != nullptr)
            delete d;
        d = o.d;
        o.d = nullptr;
     }
     return *this;
   }

   ~A(){if(d != nullptr) delete d;}
private:
   string* d = nullptr;
};

1. if there's no any c'tor, compile will provide defaults
    



pass by reference
 pro:
   - strong non-null guarantee(no need to check)
   - const ref. read only
      (allowing the flixibility of calling a function
          with a compile time constant value)
   - save time for large object
   - no object slicing problem
   - runtime polymorphism can be achieved.

 cons(regards to param passed by non-const ref)
   - readbility: if the value can be modified
       readNextValue(buf, &x) is more explicit than readNextValue(buf, x)
   - pass-by-ref makes the function note Pure.
        Pure functions have the benefits of being highly parallelized, more testable and less prone to bugs
   - lifetime guarantee is a big issue with ref(as well as pointers).
        (specially dangerous when lambda and multi-threaded prog are involved)

