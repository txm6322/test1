https://github.com/AnthonyCalandra/modern-cpp-features#range-based-for-loops
c++11 new language features
  rvalue reference
  move semantics
  special member function for move semantic
  variadic template
  forwarding reference
  initializer list
  static assertion
  auto
  lambda expression
  decltype
  type alias 
     template <typename T>
     using Vec = std::vector<T>;
     Vec<int> v;
     using String = std::string;
     String s {"foo"};
  nullptr:
     void foo(int); void foo(char*);
     foo(NULL); // ambiguous
     foo(nullptr); // foo(char*)
  strong-typed enum
  attribute
  constexpr
  user-defined literal
  delegating constructor

  final specifier
     class Foo final {...};
     class Bar: Foo { ... }; // error, Foo is not allowed to be subclassed
     struct A { virtual void Foo(); };
     struct B: A { virtual void Foo() final; };
     struct C: B { virtual void Foo(); }; // error: overrides a final function

  default function
  deleted function
     class A {
       public:
         A() = default; // provide a default impl
         A(const int) = delete; // no c'tor like this
     };
  range based loop
     array<int, 3> h{1,2 3};
     for(int x:h) ...

  converting c'tor
  explicit conversion function
  inline-namespace
  non-static data member initializer
  right angle bracket
  ref-qualified member function
  trailing return type
oo
data type in C++:
  built-in: bcd,fivw
        bool, char, double, float, int, void, wide char
  derived: array, function, pointer, reference
  user defined: struct, union, enum, class

class A {
public:
   A():{}
   A(string* res):d(res){}
   // copy c'tor
   A(A& obj) :d(new string(*obj.d)){}
   // move c'tor
   A(A&& o): d(o.d){o.d = nullptr;}
   // copy assignment
   A& operator=(A& o){if(&o != this){d = new string(*o.d);} return *this;}

   // move assignment
   A& operator=(A&& o){
     if(&o != this){
        if(d != nullptr)
            delete d;
        d = o.d;
        o.d = nullptr;
     }
     return *this;
   }

   ~A(){if(d != nullptr) delete d;}
private:
   string* d = nullptr;
};

1. if there's no any c'tor, compile will provide defaults
    



pass by reference
 pro:
   - strong non-null guarantee(no need to check)
   - const ref. read only
      (allowing the flixibility of calling a function
          with a compile time constant value)
   - save time for large object
   - no object slicing problem
   - runtime polymorphism can be achieved.

 cons(regards to param passed by non-const ref)
   - readbility: if the value can be modified
       readNextValue(buf, &x) is more explicit than readNextValue(buf, x)
   - pass-by-ref makes the function note Pure.
        Pure functions have the benefits of being highly parallelized, more testable and less prone to bugs
   - lifetime guarantee is a big issue with ref(as well as pointers).
        (specially dangerous when lambda and multi-threaded prog are involved)

