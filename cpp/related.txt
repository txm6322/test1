https://github.com/AnthonyCalandra/modern-cpp-features#range-based-for-loops
c++11 new language features
  rvalue reference
  move semantics
     mostly about performance opt.
     move without the expensive overhead of copying
     for plain old data, a move is the same as a copy
  special member function for move semantic
  variadic template
  forwarding reference
      T& & --> T&
      T& && --> T&
      T&& & --> T&
      T&& && --> T&&
      int x = 0; // x is an lvalue of type int
      auto&& al = x; // al is an lvalue of int&, binds to the lvalue x
      auto&& ar = 0; // al is an lvalue of int&&, binds to the rvalue temp 0
     void f(auto&& t){..} // since C++14 or later
     template <typename T> void f(T&& t) {..} // since C++11 or later
     int x = 0; int & y = x, int&& z = 0;
     f(0); // f(int&&)
     f(x); // f(int&);
     f(y); // f(int& &&) ==> f(int &)
     f(z); // f(int&& &) ==> f(int &)
     f(std::move(z)); f(int&& &&) ==> f(int&&)
    

  initializer list
  static assertion
  auto
  lambda expression
  decltype
  type alias 
     template <typename T>
     using Vec = std::vector<T>;
     Vec<int> v;
     using String = std::string;
     String s {"foo"};
  nullptr:
     void foo(int); void foo(char*);
     foo(NULL); // ambiguous
     foo(nullptr); // foo(char*)
  strong-typed enum
  attribute
  constexpr
  user-defined literal
  delegating constructor

  final specifier
     class Foo final {...};
     class Bar: Foo { ... }; // error, Foo is not allowed to be subclassed
     struct A { virtual void Foo(); };
     struct B: A { virtual void Foo() final; };
     struct C: B { virtual void Foo(); }; // error: overrides a final function

  deleted function
     class A {
       public:
         A() = default; // provide a default impl
         A(const int) = delete; // no c'tor like this
     };
  range based loop
     array<int, 3> h{1,2 3};
     for(int x:h) ...

  converting c'tor
  explicit conversion function
  inline-namespace
  non-static data member initializer
  right angle bracket
  ref-qualified member function
  trailing return type
oo
data type in C++:
  built-in: bcd,fivw
        bool, char, double, float, int, void, wide char
  derived: array, function, pointer, reference
  user defined: struct, union, enum, class

class A {
public:
   A():{} // default c'tor
   A(string* res):d(res){}

   A(const A& obj) :d(new string(*obj.d)){} // copy c'tor

   A(A&& o): d(o.d) {o.d = nullptr;} // move c'tor

   A& operator=(A& o) {if(&o != this){d = new string(*o.d);} return *this;} // copy assignment

   A& operator=(A&& o){ // move assignment
     if(&o != this){
        if(d != nullptr)
            delete d;
        d = o.d;
        o.d = nullptr;
     }
     return *this;
   }

   ~A(){if(d != nullptr) delete d;}
private:
   string* d = nullptr;
};


pass by reference
 pro:
   - strong non-null guarantee(no need to check)
   - const ref. read only
      (allowing the flixibility of calling a function
          with a compile time constant value)
   - save time for large object
   - no object slicing problem
   - runtime polymorphism can be achieved.

 cons(regards to param passed by non-const ref)
   - readbility: if the value can be modified
       readNextValue(buf, &x) is more explicit than readNextValue(buf, x)
   - pass-by-ref makes the function note Pure.
        Pure functions have the benefits of being highly parallelized, more testable and less prone to bugs
   - lifetime guarantee is a big issue with ref(as well as pointers).
        (specially dangerous when lambda and multi-threaded prog are involved)

